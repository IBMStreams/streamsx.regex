namespace sample;

use com.ibm.streamsx.regex.re2::*;

/**
* Run functional tests using native functions.
* 
* * Functional tests for interpreted and compiled partial/full matches.
* 
* The output:
* * regexPartialMatch: 'Hello world' matches '^Hello': true
* * regexFullMatch: 'Hello world' matches '^Hello': true
* * regexPartialMatch: 'Hello world' matches '^Hello': true
* * regexFullMatch: 'Hello world' matches '^Hello': false
* * regexFullMatch: 'Hello world' matches 'Hello world$': true
*/
composite RegexMatchNFSample {
	graph
		()as Custom_1 = Custom(){
			logic
				onProcess : {
					// Compile and index regex pattern, additionally increase max memory allocated
					regexCompile("^Hello", RegexPattern._1);
					regexCompile("Hello world$", RegexPattern._2);
					regexCompile(".*VERY_BIG_PATTERN.*", RegexPattern._3, 10000000);

					// Simple partial match (similar to SPL regex functions) - regex pattern is interpreted on each call
					printString("regexPartialMatch: 'Hello world' matches '^Hello': ");
					println(regexPartialMatch("Hello world", "^Hello"));
					
					// Simple full match (the whole string is matched) - regex pattern is interpreted on each call
					printString("regexFullMatch: 'Hello world' matches '^Hello world': ");
					println(regexFullMatch("Hello world", "^Hello world"));

					// Fast partial match - compiled regex pattern 1 is used
					printString("regexPartialMatch: 'Hello world' matches '^Hello': ");
					println(regexPartialMatch("Hello world", RegexPattern._1));
					
					// Fast full match - compiled regex pattern 1 is used
					printString("regexFullMatch: 'Hello world' matches '^Hello': ");
					println(regexFullMatch("Hello world", RegexPattern._1));
					
					// Fast full match - compiled regex pattern 2 is used
					printString("regexFullMatch: 'Hello world' matches 'Hello world$': ");
					println(regexFullMatch("Hello world", RegexPattern._2));
				}

		}
}
